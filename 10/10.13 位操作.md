## 10.13 位操作

### 10.13.1 简介
基本的位操作符有与、或、非、异或、左移、右移这6种，它们的运算规则如下表所示：

描述                 |运算规则
---------------------|-------
与                   |两个位都为1，结果才为1
或                   |两个位都为0，结果才为0
非                   |取反
异或                  |0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0
左移                  |各二进制位全部左移，高位丢弃，低位补0
右移                  |各二进制位全部右移，低位丢弃，对于无符号数，高位补0，有符号数依赖实现

接下来，我们看一下各种位操作的相关算法：

### 10.13.2 与或非运算
与运算很简单：有0结果即为0，一般用于检测二进制位中的0，以及将二进制位置为0。或运算：有1结果即为1，一般用于检测二进制位中的1，以及将二进位置为0。                             
#### 判断奇偶
只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用var&1来判断var是不是偶数，进一步判定是否被4整除，可用var&3判定（探测最低两位是否为'0'）；被8整除（var&7）以此类推。

#### 统计二进位中1的个数
这个问题通常可以用与和移位来依次探测每一位，这就需要知道数的二进制表示长度即探测次数，该方法不够灵活。还有一个更巧的办法，假设var的二进制表示为xxxx1000，则var-1为xxxx0111。最关键的一步var&(var-1)=xxxx0000，其等价的效果就是把var中最后一个1去掉了，重复该操作直到将var为0（二进制表示中没有1），就可以知道其中1的个数。该算法不用考虑二进制表示长度，具体代码如下所示：
```Java
public int countOne(int var) {
    int ret = 0;
    while (var) {
        var &= (var - 1);
        ret++;
    }
    return ret;
}
```
这个算法很有用，例如这个问题：判断一个数是否是2的整数次幂：1、2、4、8...一个数是2的整数次幂本质是：二进制表示中只有一个1，因此使用(var>0)且(var&(var-1)))==0判断即可。
此外值得一提的是var&-var表示提取var中最右边的一个1。-var的补码表示相当于~var+1，则结果显而易见。

同理可知统计二进制位中0的个数：设var的二进制表示为xxxx0111，则var+1为xxxx1000，就是把var最后一个0变为1，而后面全为0。最关键的一步var|(var+1)=xxxx1111，其等价的效果就是把var最后一个0去掉了。重复该操作直到var为全1（二进制表示中没有0），就可以知道其中0的个数。具体代码如下所示：
```Java
public int countZero(int var) {
    int ret = 0;
    while (~var) {
        var |= (var + 1);
        ret++;
    }
    return ret;
}
```
当然也可以对var取反，求出其中1的个数。

#### 变换符号
变换符号就是正数变成负数，负数变成正数：该算法比较简单，将该数取反后加1即可。

#### 翻转bit位
给出一个32位无符号整数，求出翻转bit位的结果。例如给出一个整数18（10010），返回9（01001）。本题比较简单，左右不断交换位，直到相遇。
```Java
public int reverseBits(int num) {
    int left = 0;
    int right = 31;
    while (left < right) {
        int x = (num >> left) & 1;
        int y = (num >> right) & 1;
        if(x != y) {
            num ^= (1 << left) | (1 << right);
        }
        left++;
        right--;
    }
    return num;
}
```

#### 公共首部
给出一个范围[m, n]，其中0 <= m <= n <= Integer.MAX_VALUE，求出这个范围内的所有数按位相与的结果。实际上这个题是求m和n的公共左边首部。
```Java
public int rangeBit(int m, int n) {
    int mask = Integer.MAX_VALUE;
    while((m& mask) != (n & mask)) {
        mask <<= 1;
    }
    return m & mask;
}
```

### 10.13.3 异或运算
异或运算：相同为0，不同为1。其基本性质：0^var=var，1^var=~var（~为取反），var^var=0。
#### 计算码距
在通信编码中会需要计算两个编码的码距（两个编码的二进制表示中不同位的个数）。两个数A和B，由异或的性质可知，A^B中为1的位即A和B的不同的位。

#### 交换两数
交换两数一般需要使用异或运算，异或运算的性质：具体代码如下所示
```Java
public void swap() {
    int a = 10;
    int b = 20;
    if (a != b) {
        a ^= b;
        b ^= a;
        a ^= b;
    }
}
```
简单解释一下：
第一步a=(a^b)；
第二步b=b^(a^b)，由于交换律，b^(a^b)=b^b^a，由于一个数和自己异或的结果为0且任何数与0异或都是自身，所以这一步后b被赋上a的值；
第三步a=(a^b)^b，此时则a被赋上b的值。

### 10.13.4 四则运算
这一节我们来看一下如何使用位运算实现四则运算：

#### 加法运算
第一步不考虑进位，对每一位相加：0加0与1加1的结果都0，0加1与1加0的结果都是1，这和异或的结果是一样的。对异或而言，0和0、1和1异或的结果是0，而0和1、1和0的异或结果是1。接着考虑第二步进位，对0加0、0加1、1加0而言，都不会产生进位，只有1加1时，会向前产生一个进位。此时我们可以想象成是两个数先做位与运算，然后再向左移动一位。只有两个数都是1的时候，位与得到的结果是1，其余都是0。第三步把前两个步骤的结果相加，递归调用该方法就行，具体代码如下所示：
```Java
public int add(int num1, int num2) {
    if(num2 == 0) {
        return num1;
    }

    int sum = num1 ^ num2;
    int carry = (num1 & num2) << 1;
    return add(sum, carry);
}
```

#### 减法运算
有了加法运算，减法运算就很简单了，比如num1-num2，先求得num2的补码，然后将其与num1相加即可（计算机里的减法也是这么实现的），代码如下所示：
```Java
public int sub(int num1, int num2) {
    int comNum2 = add(~num2, 1);
    return add(num1, comNum2);
}
```

#### 乘法运算
乘法运算的实现也比较简单，这里简单介绍其算法：如果对于num1*num2，从num2的第0位开始，如果其为1，则加上num1，否则则不加，以此类推，num2每向右移一位，num1的值就向左移动一位。具体代码如下所示：
```Java
public int mul(int num1, int num2){
    int ret = 0;
    while (num2 != 0) {
        if(num2 & 1) {
            ret = add(ret, num1);
        }
        num1 <<= 1;
        num2 >>= 1;
    }
    return ret;
}
```
